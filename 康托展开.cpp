/*康托展开的实质是计算当前排列在所有由小到大的全排列中的顺序 */
/*X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a2*1!+a1*0! */

/* 在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。

首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为 a[5]*(5-1)!
第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2
第三位是1，则在其之后小于1的数有0个，所以a[3]=0
第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1
最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0*/
#include<stdio.h>
int fact (int n)//求阶乘
{
    if(n==1||n==0)
        return 1;
    return n*fact(n-1) ;
}
void main()
{
    int n=0,t,i,j,s=0;
    char x[10];
    while(n>10||n<1)
    {
        printf("请输入位数n（0<=n<=10）：");
        scanf("%d",&n);
        }
    printf("{");
    for(i=1;i<=n;i++)
    {
        if(i<n)
            printf(" %d ,",i);
        else
        printf(" %d ",i);
    }
    printf("}\n");
    printf("请输入由以上数字组成的%d位数x（数字不重复）：",n);
    scanf("%s",x);
    for(i=0;i<n;i++)//求位次
    {
        t=(int)x[i]-49;//将字符类型的数字转化为整型
        for(j=0;j<i;j++)
            if(x[i]>x[j])
                t--;
        s+=t*fact(n-i-1);
    }
    printf("数x在全排列中的位次(从小到大)是 %d",s+1);
}