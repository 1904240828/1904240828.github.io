/*康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。*/
/*康托展开可求出当前排列在所有由小到大的全排列中的顺序，逆康托展开则可根据排序求出对应排列*/
/*在（1，2，3，4，5）给出61可以算出起排列组合为34152。由上述的计算过程可以容易的逆推回来，具体过程如下：

用 61 / 4! = 2余13，说明比首位小的数有2个，所以首位为3。

用 13 / 3! = 2余1，说明在第二位之后小于第二位的数有2个，所以第二位为4。

用 1 / 2! = 0余1，说明在第三位之后没有小于第三位的数，所以第三位为1。

用 1 / 1! = 1余0，说明在第二位之后小于第四位的数有1个，所以第四位为5。

最后一位自然就是剩下的数2。

通过以上分析，所求排列组合为 34152 。*/

/*关于各位数字的求法，可以提前设置一个关于1到n的自然数数组，通过所求出的商确定该位数，算出一位数之后将数组中该位置的数换成零并将0的位置换到后方，非零数换到前方。如此循环可以只通过商确定所求数字。*/
#include<stdio.h>
int fact (int n)//求阶乘
{
    if(n==1||n==0)
        return 1;
    return n*fact(n-1) ;
}
void main()
{
    int n=0,i,j,x=0,s=0;
    char num[10],a[10]={1,2,3,4,5,6,7,8,9,10};
    while(n>10||n<1)
    {
        printf("请输入位数n（0<=n<=10）：");
        scanf("%d",&n);
        }
    for(i=n;i<10;i++)
        x[i]=0;
    while(x<1||x>fact(n))
    {
        printf("请输入位次（1 <= x <= %d）：",fact(n));
        scanf("%d",&x);//位次范围有限制，为1～n！
        }
    x--;//求出比所求排列组合小的排列个数
    for(i=0;i<n;i++)
    {
        num[i]=a[x/fact(n-i-1)];
        a[x/fact(n-i-1)]=0;
        x=x%fact(n-i-1);
        for(j=0;j<n;j++)
        {
            while(a[j]==0&&a[j+1]!=0)
            {
                a[j]=a[j+1];
                a[j+1]=0;
            }
        }
    }
    printf("该位次对应的排列是 ");
    for(i=0;i<n;i++)
        printf("%d",num[i]);
}